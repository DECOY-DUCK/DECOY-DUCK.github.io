---
layout: post
title: 도커의 기본적인 사용법
subtitle: 도커는 단순한 도구가 아닙니다.
banner:
  image: https://atlassianblog.wpengine.com/wp-content/uploads/2017/01/how-to-deploy-java-apps-with-docker-a-quick-tutorial@3x-1560x760.png
  opacity: 0.618
  background: "#000"
  heading_style: "font-size: 4.25em; font-weight: bold; "
author: 오재문
categories: [DevOps]
tags: [Docker,도커교과서]
comments: true

---

##  Hollo Docker

![](https://images.velog.io/images/koo8624/post/be830b85-c877-4a85-af14-c2a8a034326c/architecture.svg)

> "애플리케이션을 필요한 모든 의존 모듈과 함께 패키징하고 어디서든 동일한 방식으로 실행할 수 있게 하자" 도커는 바로 이러한 개념에서 출발한 매우 멋진 기술이다. 도커가 실현한 이 세계에서 노트북, 데이터센터,클라우드 어디서든 애플리케이션을 똑같이 실행할 수 있다.

새로운 스택을 접했을 때 처음부터 하나씩 배워나가는 것도 좋지만 복잡한 이론 앞에 열정이 식는 경우가 있습니다. 복잡한 이론은 잠시 뒤로 하고 이 멋진 기술이 우리에게 무엇을 가져다줬는지에 집중해 보겠습니다. 아무쪼록 도커라는 놀라운 기술을 잘 이해할 수 있었으면 좋겠습니다.


---

도커는 `컨테이너`라는 경량 단위로 앱을 실행하는 기능을 제공하는 플랫폼입니다. 그래서 도커를 이해하기 위해서는 컨테이너를 먼저 이해하여야 합니다. 그래고 나서 컨테이너 어떻게 경량으로 실행할 수 있는 지에 대해 다뤄보고 마지막으로 도커가 컨테이너를 실행하는 원리에 대해 알아보겠습니다.

## 컨테이너란 무엇인가?

 `컨테이너`는 이름에서 알 수 있듯이 물건을 담는 상자와 다를 것 없습니다. 컨테이너 안에는 애플리케이션과 애플리케이션을 실행시킬 환경으로 구성되어 있습니다. 

컨테이너 내부에서는 외부를 볼 수 없습니다. 그리고 호스트 내에서 여러 컨테이너를 실행시킬 수 있습니다. 컨테이너를 사용하면 이런 `격리`와 `밀집`이라는 상반된 두 조건을 만족시키는 독특한 환경을 경험할 수 있습니다.


>밀집이란 컴퓨터에 CPU와 메모리가 허용하는 한 많은 수의 애플리케이션을 실행하는 것을 의미한다. 애플리케이션마다 요구하는 환경이 다르기 때문에 이는 생각만큼 간단한 문제는 아니다. 
>
>이것을 해결할 수 있는 기술 중 하나가 독립된 환경을 제공하는 가상 머신이다. 가상 머신은 독립된 환경을 제공한다는 점에서 컨테이너와 같아보이지만 호스트의 OS를 공유하지 않는다. 이런 사소한 차이점으로 가상머신에 비해 컨테이너는 높은 실행 속도를 보이고 더 적은 자원을 소비한다.

## 컨테이너가 애플리케이선을 경량으로 실행할 수 있는 이유



## 도커가 컨테이너를 실행하는 원리

- 도커 엔진: 도커 관리 기능을 맡는 컴포넌트이다. 이미지 캐싱 기능이 있어 새로운 이미면 새로 내려받고 이전에 내려받은 이미지면 기존 이미지를 사용한다. 또한 호스트 운영체제와 함께 도커 리소스를 만드는 일을 담당하다. 도커 엔진은 도커 API를 통해 맡은 기능을 수행한다.

- 도커 CLI: 도커 API의 클라이언트다. docker 명령을 사용할 때 도커 API를 호출한다.

---

## **도커 이미지 만들기**

도커를 공부하면서 여러 이미지를 빌드해야 할 것이다. 도커 이미지는 도커를 지탱하고 있는 핵심 중 하나다.
이번 장에서 이미지의 동작 원리 컨테이너와 이미지의 관계에 대해 자세히 알아보고 도커 이미지를 직접 만들어 보자.

## **이미지 레이어**

도커 이미지를 가져오는 명령어를 보내면 도커는 가장 먼저 이미지를 찾기 위해 도커 허브에 접근한다. 그리고 도커 허브와 같이 이미지를 제공하는 저장소를 `레지스트리 registry`라고 부른다.

![image](https://user-images.githubusercontent.com/51963264/191139653-942f2e38-3a2d-4d76-9674-6b51cd0490ae.png)

이미지를 내려받는 과정을 보면 여러 건을 파일을 내려 받는 모습이 보이는데 이들 각 파일을 이미지 레이어라고 부른다. 이 과정을 통해 도커 이미지는 물리적으로 여러개의 작은 파일로 구성된다는 것을 알 수 있다. 도커는 이러한 작은 파일들을 조립해 컨테이너의 내부 시스템을 만든다.

도커 이미지에는 컨테이너를 만들기 위한 모든 파일 뿐만 아니라 이미지 자신에 대한 메타정보도 포함하고 있다. 아래의 명령어를 통해 현재 이미지가 만들어지기까지 어떤 레이어들을 거쳤는지, 각 레이어의 사이즈는 어땠는지 등의 정보를 볼 수 있다.

```bash
docker image history [OPTIONS] IMAGE
```

<img width="930" alt="image" src="https://user-images.githubusercontent.com/51963264/191129912-61102fad-0ab2-4c30-bd6c-47ea730baef2.png">

여기서 중요한 점은 만약 이미지를 가져올 때 중복된 이미지 레이어가 있다면 새로 가져오지 않고 캐싱되어 있는 이미지 레이어를 공유한다는 것이다. 이러한 특성으로 인해 저장 공간을 획기적으로 줄일 수 있는데
만약 수정할 수 있다면 레이어를 공유하는 다른 이미지에 영향을 주기 때문에 레이어를 읽기 전용으로 만들어 두어 수정을 방지한다.

<img width="532" alt="image" src="https://user-images.githubusercontent.com/51963264/191144684-2587515a-625a-4c8a-8d62-df53f51e2cec.png">   


>이미지에서 run 명령어를 통해 컨테이너가 만들어지는 순간 컨테이너 레이어가 최상위에 추가되어 동작하는데 사용자가 입력하는 모든 행동은 container layer에서 이루어지며, 환경을 구성하는 이미지 레이어를 변경하는 것은 불가능하다. 

## **Dockerfile**

Dockerfile은 애플리케이션을 패키징하기 위한 스크립트다. Dockerfile은 인스트럭션으로 구성되는데 인스트럭션을 실행한 결과로 도커 이미지가 만들어 진다. 스크립트는 간단한 문법으로 되어 있기 때문에 처음 접하더라도 어느 정도 이해하고 구현할 수 있을 것이다. 

사실 대부분 도커이미지는 Dockerfile을 통해 만들 것이다. 하지만 다른 한가지 방법이 더 있는데 실습과제를 통해서 직접 다뤄볼 예정이다.

## **Dockerfile 스크립트 최적화**

Dockerfile 스크립트를 작성할 때 잘 수정되지 않는 인스트럭션일수록 상위 쪽으로 배치해야 한다.이렇게 해야 캐시에 저장된 이미지 레이어를 많이 재사용 할 수 있기 때문이다. 이미지를 빌드 하고 수정한 후 다시 빌드할 경우 새로운 이미지 레이어가 생긴다. 이때 Dockerfile 스크립트는 이미지 레이어와 1:1로 연결되는데 도커 캐시에 일치하는 레이어가 있는지 해시값을 이용해서 확인하게 된다. 만약 전에 사용한 레이어가 있다면 캐시된 레이어를 재사용하게 되고 중간에 변경된 레이어가 있다면 새로운 이미지레이어를 만든다. 그 뒤 레이어도 변경된것이 없더라도 새로운 레이어로 만들어 진다.

## 애플리케이션 소스 코드에서 이미지까지

![image](https://user-images.githubusercontent.com/51963264/193109903-d68b44a4-841c-4683-a45b-d1c4a66becaf.png)
image.png

현대 IT기술을 주도하는 요소 중 하나는 `일관성`이다. 개발 팀은 모든 프로젝트에서 같은 도구, 같은 프로세스, 동일한 런타임을 사용하길 원한다. 도커를 사용하면 이러한 요구를 만족시킬 수 있다.

## 멀티스테이지 빌드

![image](https://user-images.githubusercontent.com/51963264/193110077-d1e258f9-b6bf-4c06-b020-23bd084190c7.png)

앞서 배운 최적화와 마찬가지로 이미지를 작게 만드려는 여러가지 시도가 있었다. 이미지가 작으면 작을수록 배포시간은 짧아지기 때문이다. 이러한 시도 끝에 하나의 도커파일에 여러 빌드 단계를 나눠 빌드가 순차적으로 이뤄지는 멀티스테이지 빌드 패턴이 탄생하게 되었다.

각 빌드단계는 서로 격리되어 있다. 빌드 단계 별로 기반 이미지도 다를 수 있다. 그리고 어느 단계라도 실패하면 전체 빌드가 실패한다. 이 패턴을 사용하면 어떤 복잡한 애플리케이션이라도 하나의 도커파일로 빌드 할 수 있다. 

이런 패턴을 사용해서 컨테이너로 애플리케이션을 빌드하면 어떤 이점이 있는지는 다음과 같이 정리할 수 있다.

**표준화**

로컬 컴퓨터에 어떤 도구가 설치되어 있는지와는 상관없는 모든 빌드 과정은 컨테이너 안에서만 이뤄진다. 그리고 컨테이너 안의 모든 도구들은 모두 정확한 버전을 가진다. 이는 새로 팀에 합류하는 신입 개발자가 즉시 개발 환경을 갖출 수 있고 다른 개발자 간의 도구 버전 차이로 인한 빌드 실패 가능성을 크게 줄일 수 있다.

**최종 이미지를 작게 유지할 수 있다**

멀티 스테이지를 사용하면 최종산출물인 이미지에 불필요한 도구는 빼버릴 수 있다. 빌드 스테이지에서 빌드에 필요한 종속성, 빌드 후 바이너리를 만들고 실제로 동작하는 러닝 이미지에서 빌드 스테이지에서 만들어낸 바이너리만 받아서 사용하는 방식으로 이미지 크기를 줄여 용량 뿐만 아니라 배포 시간을 줄일 수 있다. 거기다 애플리케이션의 의존 모듈자체 또한 줄어 취약점을 이용한 외부 공격 가능성도 차단할 수 있다.

---

이제까지 도커의 핵심 워크플로인 빌드와 실행에 대해 배웠다면 지금부터 공유에 대해 배워보겠습니다.

## 