---
layout: post
title: Docker dive
subtitle: 도커는 단순한 도구가 아닙니다.
banner:
  image: https://atlassianblog.wpengine.com/wp-content/uploads/2017/01/how-to-deploy-java-apps-with-docker-a-quick-tutorial@3x-1560x760.png
  opacity: 0.618
  background: "#000"
  heading_style: "font-size: 4.25em; font-weight: bold; "
author: 오재문
categories: [DevOps]
tags: [Docker,도커교과서]
comments: true

---

##  Hollo Docker


> "애플리케이션을 필요한 모든 의존 모듈과 함께 패키징하고 어디서든 동일한 방식으로 실행할 수 있게 하자" 도커는 바로 이러한 개념에서 출발한 매우 멋진 기술이다. 도커가 실현한 이 세계에서 노트북, 데이터센터,클라우드 어디서든 애플리케이션을 똑같이 실행할 수 있다.

새로운 스택을 접했을 때 처음부터 하나씩 배워나가는 것도 좋지만 복잡한 이론 앞에 열정이 식는 경우가 있습니다. 

복잡한 이론은 잠시 뒤로 하고 이 멋진 기술이 우리에게 무엇을 가져다줬는지에 집중해 보겠습니다. 아무쪼록 도커라는 놀라운 기술을 잘 이해할 수 있었으면 좋겠습니다.

---

## 빌드 공유 실행

![image](https://user-images.githubusercontent.com/51963264/224186916-b1472474-39b4-4f3d-ab50-4aa69e821c2a.png)


도커의 핵심은 `빌드`,`공유`,`실행`으로 정리할 수 있습니다. 먼저 애플리케이션을 컨테이너에서 실행할 수 있도록 패키징하고 다른 사람이 패키지를 사용할 수 있도록 공유한 다음, 이 패키지를 내려받은 사람이 컨테이너를 통해 애플리케이션을 실행합니다. 도커는 그것을 가능하게 하는 컴포넌트들로 구성되어 있습니다. 

도커는 `컨테이너`라는 경량 단위로 앱을 실행하는 기능을 제공하는 플랫폼입니다. 때문에 도커를 이용해 애플리케이션을 실행시키려면 컨테이너라는 기술을 사용하게 됩니다. 

## 컨테이너

`컨테이너`는 이름에서 알 수 있듯이 물건을 담는 상자와 다를 것 없습니다. 컨테이너 안에는 애플리케이션과 애플리케이션을 실행시킬 환경으로 구성되어 있습니다. 

도커는 컨테이너의 호스트명,IP주소,파일 시스템 등과 같은 가상 리소스들을  관리합니다. 컨테이너들은 서로 독립된 환경을 갖지만 호스트의 CPU,메모리 및 운영체제를 공유하게 됩니다. 경우에 따라서 도커는 호스트의 네트워크 계층에서 트래픽을 가로채 필요한 것을 컨테이너에 전달하기도 합니다.

독립된 환경을 가진다는 것은 꽤 중요한 문제 입니다. 한 호스트 내에  다수의 애플리케이션을 실행시키는 것은 많은 제약이 따르기 때문입니다. 서로 호환되지 않는 라이브러리를 사용하는 경우나 한 애플리케이션이 리소스를 과도하게 점유할 수도 있습니다. 이런 문제는 호스트 추가 및 관리 등의 비용 문제로 이어질 수 있습니다. 컨테이너 등장 이전 시대에서는 가상머신을 이용해 환경을 격리시킴으로써 이 문제를 해결했습니다. 

가상머신과 컨테이너의 유일한 차이는 호스트의 운영체제를 공유입니다. 가상 머신은 각각 별도의 운영체제를 필요로하고 컨테이너는 호스트의 운영체제를 공유하기 때문에 그 만큼 필요한 리소스가 줄어들게 됩니다. 때문에 컨테이너는 가상머신과 비교했을 때 애플리케이선을 경량으로 실행할 수 있습니다.

---

## 이미지

도커에서 `이미지`는 컨테이너와 마찬가지로 도커를 지탱하고 있는 `핵심 중 하나`입니다. 모든 컨테이너는 이미지를 바탕으로 실행되며, 이 때 이미지는 컨테이너가 실행되는 파일 시스템입니다.

도커 이미지를 가져오는 명령어를 보내면 도커는 가장 먼저 이미지를 찾기 위해 도커 허브에 접근하게 됩니다. 이때 도커 허브와 같이 이미지를 제공하는 저장소를 `레지스트리 registry`라고 부릅니다.

### 이미지 레이어


![image](https://user-images.githubusercontent.com/51963264/191139653-942f2e38-3a2d-4d76-9674-6b51cd0490ae.png)

이미지를 내려받는 과정을 보면 여러 건을 파일을 내려 받는 모습이 보이는데 이들 각 파일을 `이미지 레이어`라고 부릅니다. 이 과정을 통해 도커 이미지는 물리적으로 여러개의 작은 파일로 구성된다는 것을 알 수 있다. 도커는 이러한 작은 파일들을 조립해 컨테이너의 내부 시스템을 만듭니다.

```bash
#명령어를 통해 알 수도 있습니다.
docker image history [OPTIONS] IMAGE
```

여기서 중요한 점은 만약 이미지를 가져올 때 중복된 이미지 레이어가 있다면 해당 이미지 레이어를 공유한다는 것입니다. 이러한 특성으로 인해 저장 공간을 획기적으로 줄일 수 있는데 만약 그 이미지 레이어가 수정된다면 레이어를 공유하는 다른 이미지에 영향을 주기 때문에 레이어를 읽기 전용으로 만들어 두어 수정을 방지합니다.

>이미지에서 run 명령어를 통해 컨테이너가 만들어지는 순간 컨테이너 레이어가 최상위에 추가되어 동작하는데 사용자가 입력하는 모든 행동은 container layer에서 이루어지며, 환경을 구성하는 이미지 레이어를 변경하는 것은 불가능하다. 

## Dockerfile

특별한 경우를 제외하면 대부분의 도커 이미지는 `Dockerfile`을 통해 만듭니다. Dockerfile은 인스트럭션으로 구성되는데 도커는 인스트럭션을 이미지 레이어와 일대일 대응되게 도커 이미지를 만들어냅니다.

Dockerfile 스크립트를 잘 작성하는 것만으로도 사간, 저장 공간, 네트워크 대역폭을 절약할 수 있습니다. `Dockerfile 스크립트 최적화`라고 불리는데 
알아보겠습니다.

도커는 한번 사용한 이미지 레이어는 캐시 메모리에 저장합니다. 그리고 해시값을 이용해 이미지 레이어를 식별합니다. 만약 Dockerfile 스크립트에서 전에 사용한 레이어가 있다면 캐시된 레이어를 재사용하게 되고 없다면 캐시 미스가 발생해 해당 인스트럭션이 실행하게 됩니다. 그 다음 인스트럭션은 수정된 것인지 확인하지 않고 바로 실행 됩니다. 때문에 Dockerfile 스크립트를 작성할때 잘 수정되지 않는 인스트럭션일 수록 상위 쪽으로 배치해야 합니다. 그렇게 해야 캐시에 저장된 이미지 레이어를 많이 재사용 할 수 있기 때문입니다. 

---

## 마치며

Docker는 단일 컨테이너 관리에 적합하도록 만들어져 있습니다. 하지만 모든 일을 단일 컴포넌트가 맡아 수행하는 애플리케이션은 그리 많지 않습니다. 애플리케이션은 대개 여러 요소로 분할되어 구성되기 마련입니다. 때문에 여러 컨테이너를 실행하고 관리하는 법은 도커가 아닌 조금 다른 기술을 통해 해결해야 합니다.